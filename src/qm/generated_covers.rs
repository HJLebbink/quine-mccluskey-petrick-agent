//! Generated AVX-512 covers function
//!
//! This file contains the `_mm512_covers_4_4_4_1` function generated by
//! bitwise-agent-rust using ABC synthesis.
//!
//! **Source**: C:\Source\Private\rust\bitwise-rust-agent\generated\rust\_mm512_covers_4_4_4_1.rs

#![allow(unused_unsafe)]

#[cfg(all(target_arch = "x86_64", feature = "simd"))]
use core::arch::x86_64::*;

/// AVX-512 optimized coverage check function
///
/// Processes 512 coverage checks in parallel using bit-transposed data.
///
/// # Input Layout
/// - `input[0..3]`: Implicant value (4 bit planes)
/// - `input[4..7]`: Don't care mask (4 bit planes)
/// - `input[8..11]`: Minterm value (4 bit planes)
///
/// # Output
/// - `output[0]`: 512-bit result (1 = covered, 0 = not covered)
///
/// # Safety
/// Requires AVX-512F support. Use `is_x86_feature_detected!("avx512f")` to check.
#[cfg(all(target_arch = "x86_64", feature = "simd"))]
#[target_feature(enable = "avx512f")]
pub unsafe fn _mm512_covers_4_4_4_1(input: &[__m512i; 12], output: &mut [__m512i; 1]) {
    let i00 = input[0];
    let i01 = input[1];
    let i02 = input[2];
    let i03 = input[3];
    let i04 = input[4];
    let i05 = input[5];
    let i06 = input[6];
    let i07 = input[7];
    let i08 = input[8];
    let i09 = input[9];
    let i10 = input[10];
    let i11 = input[11];
    let n18 = _mm512_ternarylogic_epi64::<0x12>(i11, i07, i03); // node 4
    let n19 = _mm512_ternarylogic_epi64::<0x12>(i08, i04, i00); // node 5
    let n17 = _mm512_ternarylogic_epi64::<0x12>(i09, i05, i01); // node 3
    let n16 = _mm512_ternarylogic_epi64::<0x12>(i10, i06, i02); // node 2
    let n15 = _mm512_ternarylogic_epi64::<0x01>(n18, n17, n16); // node 1
    let f0 = _mm512_andnot_si512(n19, n15); // node 0
    output[0] = f0;
}
